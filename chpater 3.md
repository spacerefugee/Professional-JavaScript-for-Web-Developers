## 目录
- [基本概念](#基本概念)
  - [3.1 语法](#3.1-语法)
    - [3.1.1 区分大小写](#3.1.1-区分大小写)
    - [3.1.2 标识符](#3.1.2-标识符)
    - [3.1.3 注释](#3.1.3-注释)
	- [3.1.4 严格模式](#3.1.4-严格模式)
	- [3.1.5 语句](3.1.5-语句)
  - [3.2 关键字和保留字](#3.2-关键字和保留字)
  - [3.3 变量](#3.3-变量)
  - [3.4 数据类型](#3.4 数据类型)
    - [3.4.1 typeof操作符](#3.4.1-typeof操作符)
    - [3.4.2 Undefined类型](#3.4.2-Undefined类型)
    - [3.4.3 Null类型](#3.4.3-Null类型)
    - [3.4.4 Boolean类型](#3.4.4-Boolean类型)
    - [3.4.5 Number类型](#3.4.5-Number类型)
      - [浮点数值](#浮点数值)
      - [数值范围](#数值范围)
      - [NaN](#NaN)
      - [数值转换](#数值转换)
    - [3.4.6 String类型](#3.4.6-String类型)
      - [字符字面量](#字符字面量)
      - [字符串的特点](#字符串的特点)
      - [转换为字符串](#转换为字符串)
    - [3.4.7 Object类型](#3.4.7-Object类型)
  - [3.5 操作符](#3.5-操作符)
    - [3.5.1 一元操作符](#3.5.1-一元操作符)
      - [递增和递减操作符](#递增和递减操作符)
      - [一元加和减操作符](#一元加和减操作符)
    - [3.5.2 位操作符](#3.5.2-位操作符)
      - [按位非(NOT)](#按位非NOT)
      - [按位与(AND)](#按位与AND)
      - [按位或(OR)](#按位或OR)
      - [按位异或(XOR)](#按位异或XOR)
      - [左移](#左移)
      - [有符号右移](#有符号右移)
      - [无符号右移](#无符号右移)
    - [3.5.3 布尔操作符](#3.5.3-布尔操作符)
      - [逻辑非](#逻辑非)
      - [逻辑与](#逻辑与)
      - [逻辑或](#逻辑或)
    - [3.5.4 乘性操作符](#3.5.4-乘性操作符)
      - [乘法](#乘法)
      - [除法](#除法)
      - [求模](#求模)
    - [3.5.5 加性操作符](#3.5.5-加性操作符)
      - [加法](#加法)
      - [减法](#减法)
    - [3.5.6 关系操作符](#3.5.6-关系操作符)
    - [3.5.7 相等操作符](#3.5.7-相等操作符)
      - [相等和不相等](#相等和不相等)
      - [全等和不全等](#全等和不全等)
    - [3.5.8 条件从操作符](#3.5.8-条件从操作符)
    - [3.5.9 赋值操作符](#3.5.9-赋值操作符)
    - [3.5.10 逗号操作符](#3.5.10-逗号操作符)
  - [3.6 语句](#3.6-语句)
    - [3.6.1 if语句](#3.6.1-if语句)
    - [3.6.2 do-while语句](#3.6.2-do-while语句)
    - [3.6.3 while语句](#3.6.3-while语句)
    - [3.6.4 for语句](#3.6.4-for语句)
    - [3.6.5 for-in语句](#3.6.5-for-in语句)
    - [3.6.6 label语句](#3.6.6-label语句)
    - [3.6.7 break和continue语句](#3.6.7-break和continue语句)
    - [3.6.8 with语句](#3.6.8-with语句)
    - [3.6.9 switch语句](#3.6.9-switch语句)
  - [3.7 函数](#3.7-函数)
    - [3.7.1 理解参数](#3.7.1-理解参数)
    - [3.7.2 没有重载](#3.7.2-没有重载)
    
### 第3章 基本概念
#### 3.1 语法
##### 3.1.1 区分大小写
- ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。
- ECMAScrpit中的一切（变量、函数名和操作符）都区分大小写。

##### 3.1.2 标识符
- 标识符第一个字符必须是一个字母、下划线(_)或一个美元符号($)，其他字符可以是字母、下划线、美元符号或数字。不能把关键字、保留字、true、false和null用作标识符

##### 3.1.3 注释
- ECMAScript使用的是C风格的的注释，单行注释以两个斜杠(//)开头，块注释由一个斜杠和一个星号(/\*)开头，以一个星号和一个斜杠(\*/)结束。

##### 3.1.4 严格模式
- 严格模式可以在顶部添加代码"use strict"开启，严格模式下，JavaScript的执行结果会有很大不同。

##### 3.1.5 语句
- ECMAScript中的语句由一个分号(;)结尾，如果省略分号，则由解析器确定语句的结尾。
- 虽然语句结尾的分号不是必须的，但是建议任何时候都不要省略分号。
- 可以使用C风格的语法把多条语句组合到一个代码块中，即代码块以左花括号({)开头，以右花括号(})结尾。
- 虽然条件控制语句（如if语句）只在执行多条语句的情况下才要求使用，但最佳实践是始终在控制语句中使用代码块——即使代码块中只有一条语句。

#### 3.2 关键字和保留字
- ECMA-262描述了一组具有特定用途的**关键字**，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript的全部关键字（带\*号是第5版新增的关键字）：  
break do instanceof typeof case else new var catch finally return void continue for switch while debugger\* function this with delete in try
- ECMA-262还描述了另外一组不能用作标识符的**保留字**，尽管保留字在这门语言中还没有任何特定的用途，但他们有可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字：  
abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws conts goto private transient debugger implements protected volatile double import public
- 第5版把在费严格模式下运行时的保留字缩减为下列这些：  
class enum extends super const export import
- 在严格模式下，第5版还对以下保留字施加了限制：  
implements package public interface private static let protected yield
- 使用保关键字作标识符会导致"Identifier Expected"错误。

#### 3.3 变量
- ECMAScpirt的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。
- 省略var操作符可以创建一个全局变量，但是不推荐这样做。
- 可以是用一条局域定义多个变量，用逗号分隔开，如：
```
var a = 'a',
    b = false,
    c = 1
```

#### 3.4 数据类型
- ECMAScript有5种简单的数据类型（也成为基本数据类型）： 
Undefined, Null, Boolean, Number, String
- 还有一种复杂数据类型：Object

##### 3.4.1 typeof操作符
- 对一个值使用typeof操作符可以能返回下列某个字符串：  
"undefined"——如果这个值未定义  
"boolean"——如果这个值是布尔值  
"string"——如果这个值是字符串  
"number"——如果这个值是数值  
"object"——如果这个值是对象或者null  
"function"——如果这个值是函数  

##### 3.4.2 Undefined类型
- Undefined类型只有一个值，即特殊的undefined。在使用var生命变量但未对其加以初始化时，这个变量的值就是undefined

##### 3.4.3 Null类型
- Null类型是第二个只有一个值的数据类型，这个特殊值是null。
- 从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回"object"的原因。
- 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null值而不是其他值。这样一来检查null值就可以知道变量是否保存了对象的引用。
- undefined值是派生自null值，因此ECMA-262规定对它们的相等性测试要返回true。

##### 3.4.4 Boolean类型
- Boolean类型是ECMAScript中使用得最多的一种类型，只有两个字面值：true和false
- 这两个值与数字值不是一回事，因此true不等于1，false不等于0。
- Boolean类型字面值是区分大小写的，True和False（以及其他混合大小写的形式）都不是Boolean值，只是标识符。
- 要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。
- 可以对任何数据类型的值调用Boolean()函数，下表给出了各种数据类型及其对应的转换规则：

数据类型|转换为true的值|转换为false的值
---|---|---
Boolean|true|false
String|任何非空字符串|''(空字符串)
Number|任何非零数字值(包括无穷大)|0和NaN
Object|任何对象|null
Undefined|N/A(不适用)|undefined
- 在流程控制语句（如if语句）会自动根据上述规则转换成对应的Boolean值

##### 3.4.5 Number类型
- 数值字面量格式可以以十进制整数、浮点数值、八进制或者十六进制来表示。
- 八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0\~7)，如果字面值中的数值超出范围那么前导零将被忽略，后面的数值将被当做十进制数值解析。
- 八进制字面量在严格模式下是无效的，会导致支持的JavaScript引擎抛出错误。
- 十六进制字面值的前两位必须是0x，后跟任何十六进制数字(0\~9及A\~F)，其中字母A~F可以大写也可以小写。
- 在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

###### 1. 浮点数值
- 浮点数值就是该数值中必须包含一个小数点，并且小数点后必须至少有一位数字。虽然小数点前可以没有整数，但是不推荐这种写法。
- 由于保存浮点数值所需的内存空间是保存整数数值的两倍，因此ECMAScript会将不失时机地将浮点数值转换为整数数值，如小数点后无任何数字或者浮点数值本身表示是整数（如1.0）。
- 对于极大或者极小的数值可以用e表示法（科学计数法）表示。如3.123e7即3.123\*10的7次方，3e-7即3\*10的-7次方。
- 浮点数值的最高京都是17位小数，但在进行算数计算是其精确度远远不如整数。如0.1+0.2结果不是0.3，而是0.30000000000000004，这个小小的舍入误差会导致无法测试特定的浮点数值。

###### 2. 数值范围
- ECMAScript能够表示的最小值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值是5e-324。
- ECMAScript能够表示的最大值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。
- 如果数值超过了最大值则会被自动转换成特殊的Infinity(正无穷)值，如果超过最小值则会被转换成-Infinity(负无穷)。
- Infinity值不能参与计算，可以使用isFinity()函数判断是否数值是否有穷。

###### 3. NaN
- NaN即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。比如任何数值除以0会返回NaN。
- NaN有两个特点：  
任何涉及NaN的操作(例如NaN/10)都会返回NaN
NaN与任何值都不相等，包括NaN本身
- 可以使用isNaN()函数判断参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值，例如字符串"10"或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。

###### 4. 数值转换
- 有三个函数可以把非数值转换为数值：  
1. Number()  
2. parseInt()  
3. parseFloat()
- 第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。
- **Number()** 函数的转换规则：
  - 如果是Boolean值，true和false分别被转换为1和0。  
  - 如果是数字值，只是简单的传入和返回。  
  - 如果是null值，返回0。  
  - 如果是undefined，返回NaN。  
  - 如果是字符串，遵循下列规则：  
    - 如果字符串只包含数字（包括前面带正负号的情况），则将其转换为十进制数值。即"1"会变成1，"123"会变成123，而"011"会变成11（前导的零被忽略）。
    - 如果字符串包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样也会忽略前导0）。
    - 如果字符串包含有效的十六进制格式，如"0xf"，则将其转换为相同大小的十进制整数值。
    - 如果字符串为空，则转换为0。 
  - 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再依照前面的规则转换返回的字符串。
- 由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的parseInt()函数。
- **parseInt()** 函数会忽略字符串前面的空格，直到找到第一个非空格字符，如果第一个字符不是数字字符或者负号，就会返回NaN，也就是说parseInt()转换空字符串会返回NaN（Number()返回0）。如果第一个字符是数字字符，则继续解析第二个字符，直到解析完字符串或者遇到非数字字符。小数点不是数字字符所以不能被解析（如22.5会被转换为22）。
- parseInt()可以转换八进制（0开头切后跟数字字符）和十六进制（0x开头且后跟数字字符）。
- parseInt()在处理八进制字符串时ECMAScript3和ECMAScript5存在分歧，ECMAScript5不具有解析八进制值的能力，但是可以使用这个函数的第二个参数，指定基数（即多少进制），如要转换的值是十六进制格式的字符串，指定基数16就可以保证得到正确的结果。
- 为了避免错误解析，建议无论在什么情况下都明确指定基数。
- **parseFloat()** 函数和parseInt()类似，从第一个字符开始解析，知道字符串结束或遇到无效的浮点数字字符为止（第一个小数点有效，之后的小数点无效）。parseFloat()始终会忽略前导零，只能解析十进制，不能解析八进制或者十六进制。

##### 3.4.6 String类型
- 字符串可以由双引号(")或者单引号(')表示。两种语法形式没有什么区别，但是开头是双引号结尾必须是双引号，开头是单引号结尾也必须是单引号。

###### 1. 字符字面量
- 字符字面量也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。

字面量|含义
---|---
\n|换行
\t|制表
\b|空格
\r|回车
\f|进制
\\\\|斜杠
\\'|单引号(')，在用单引号表示的字符串中使用。例如:'he say \\'hey.\\''
\\"|双引号(")，在用双引号表示的字符串中使用。例如:"he say \\"hey.\\""
\xnn|以十六进制代码nn表示的一个字符(其中n为0~F)，例如:\x41表示"A"
\unnnn|以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)，例如:\u03a3表示"∑"

- 字面量可以出现在字符串中任意位置，而且也将被作为一个字符来解析。

###### 2. 字符串的特点
- ECMAScript中的字符串是不可变的，也就是说字符串一旦创建它们的值就不能改变。要改变某个变量保存的字符串首先要销毁原来的字符串然后再用新的字符串填充该变量。

###### 3. 转换为字符串
- 使用几乎每个值都有的toString()方法。null和undefined没有这个方法。
- toString()方法可以传递参数，默认情况下以十进制返回数值的字符串表示，通过传递基数可以输出二进制、八进制、十六进制乃至其他任意有效进制格式表示的字符串值。
- 在不知道要转换的值是不是null或undefined的情况下可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。如果是null则返回"null"，如果是undefined则返回"undefined"。

##### 3.4.7 Object类型
- ECMAScript中的对象其实就是一组数据和功能的集合。
- 可以通过new操作符后跟要创建的对象类型和名称来创建。
```
var o = new Object();
// 如果不传递参数可以省略括号（但这不是推荐的做法）；
var o = new Object;
```
- Object的每个实例都具有下列属性和方法：
  - Constructor：保存着用于创建当前对象的函数。
  - hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在。
  - isPrototypeOf(Object)：用于检查传入的对象是否另一个对象的原型。
  - propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够用for-in语句来枚举。
  - toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
  - toString()：返回对象的字符串表示。
  - valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同。

#### 3.5 操作符
- 操作符包括算数操作符（如加减号）、位操作符、关系操作符和相等操作符。
- ECMAScript操作符可以适用于很多值，例如字符串、数字值、布尔值甚至对象。

##### 3.5.1 一元操作符
- 只能操作一个值的操作符叫做一元操作符。

###### 1. 递增和递减操作符
- 递增操作符以两个加号(++)表示，递减操作符以两个减号(--)表示
- 前置型位于要操作的变量之前，变量的值在被求值以前改变的。
- 后置型位于要操作的变量之后，变量的值在被求值之后改变的。
- 不仅仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。
- 在应用于不同的值时，递增和递减操作符遵循下列规则：
  - 应用于包含有效数字字符的字符串时，先将其转换为数字值再进行加减操作，字符串变量变成数值变量
  - 应用于不包含有效数字字符的字符串时，将变量的值设置为NaN，字符串变量变成数值变量。
  - 应用于布尔值false时，先将其转换为0再执行加减操作，布尔值变量变成数值变量。
  - 应用于布尔值true时，先将其转换为1再执行加减操作，布尔值变量变成数值变量。
  - 应用于浮点数值时，执行加减操作。
  - 应用于对象时，先调用对象的valueOf()方法取得一个可供操作的值，然后对该值进行前述操作。如果结果是NaN，则再调用toString()方法后再应用前述操作。对象变量变成数值变量。

###### 2. 一元加和减操作符
- 一元加操作符以一个加号(+)表示，一元减操作符以一个减号(-)表示
- 在对非数值应用一元加操作符或一元减操作符时，该操作符会像Number()转型函数一样对这个值执行转换。

##### 3.5.2 位操作符
- 位操作符用于最基本的层次上，按内存中表示数值的位来操作数值。
- 对于有符号的整数，32位中的前31位用于表示整数的值。第32位用于表示数值的符号：0表示整数，1表示负数。这个表示符号的位叫做符号位。
- 符号位的值决定了其他位数值的格式。正数以纯二进制格式储存。负数使用二进制补码储存（先求这个数值绝对值的二进制码，再求二进制反码，即0和1互换，最后二进制反码加1）。
- ECMAScript会尽力向我们因此所有这些信息，换句话说，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数的绝对值的二进制码前面加上了一个负号。如下例子：
```
var num = -18;
alert(num.toString(2)); // "-10010"
```
- 在ECMAScript中，对数值应用位操作符时，后台会发生如下转换过程：64位数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这会导致一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。
- 对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值，然后再应用位操作，得到的结果是一个数值。

###### 1. 按位非(NOT)
- 按位非操作符由一个波浪线(~)表示，执行按位非的结果就是返回数值的反码。
- 按位非操作的本质：操作数的负值减1。

###### 2. 按位与(AND)
- 按位与操作符由一个和号字符(&)表示，它有两个操作符数。
- 从本质上讲，按位与操作就是将两个数值的每一位对齐，然后根据下表中的规则，对应同位置上的两个数执行AND操作：

第一个数值的位|第二个数值的位|结果
---|---|---
1|1|1
1|0|0
0|1|0
0|0|0
- 简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都为0。

###### 3. 按位或(OR)
- 按位或操作符由一个竖线符号(|)表示，同样也有两个操作数。按位或操作遵循下面这个真值表：

第一个数值的位|第二个数值的位|结果
---|---|---
1|1|1
1|0|1
0|1|1
0|0|0
- 简而言之，按位与操作只在两个数值的对应位都是0时才返回0，任何一位是1，结果都为1。

###### 4. 按位异或(XOR)
- 按位异或操作符由一个插入符号(^)表示，也有两个操作数，一下是按位异或的真值表：

第一个数值的位|第二个数值的位|结果
---|---|---
1|1|0
1|0|1
0|1|1
0|0|0
- 按位异或与按位或不同之处在于，这个操作在两个数值对应位上只有一个1时才返回1，度过对应的两位都是1或都是0，则返回0

###### 5. 左移
- 左移操作符由两个小于号(<<)表示，这个符号会将数值的所有位向左移指定的位数。例如将数值2（二进制码为10）向左移5位，结果就是64（二进制码为1000000）。
- 向左移位后，原数值右侧多出的空位会以0来填充。
- 左移不会影响操作数的符号位。

###### 6. 有符号右移
- 有符号的右移操作符由两个大于号(>>)表示，这个操作符会将数值向右移动，但保留符号位。例如将数值64（二进制码为1000000）向右移5位，结果就是2（二进制码为10）。
- 向右移位后，原数值左侧多出的空位会以符号位的数值来填充。

###### 7. 无符号右移
- 无符号右移操作符由三个大于号(>>>)表示，这个操作符会将数值的所有32位都向右移动。
- 对正数来说，无符号右移的结果与有符号右移相同。
- 对负数来说，右移会以0来填充空位，右移过程中会把负数的二进制码当成正数的二进制码，而且由于负数以其绝对值的二进制补码形式表示，因此会导致无符号右移后的结果非常之大。

##### 3.5.3 布尔操作符
- 布尔操作符有三个：非(NOT)、与(AND)和或(OR)。

###### 1. 逻辑非
- 逻辑非操作符由一个叹号(!)表示，可以应用于ECMAscript中的任何值。
- 逻辑非操作符首先会将它的操作数转为一个布尔值，然后再对其求反。

###### 2. 逻辑与
- 逻辑与操作符由两个和号(&&)表示，有两个操作数，真值表如下：

第一个操作数|第二个操作数|结果
---|---|---
true|true|true
true|false|false
false|true|false
false|false|false
- 逻辑与操作可以应用于任何类型的操作数，在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，此时遵循下列规则：
  - 如果第一个操作数是对象，则返回第二个操作数；
  - 如果第二个操作数是对象，则只有在第一个操作数的求职结果为true的情况下才会返回对象；
  - 如果两个操作数都是对象，则返回第二个操作数；
  - 如果有一个操作数是null，则返回null；
  - 如果有一个操作数是NaN，则返回NaN；
  - 如果有一个操作数是undefined，则返回undefined；
- 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，就不会对第二个操作数求值。

###### 3. 逻辑或
- 逻辑或操作符由两个竖线符号(||)表示，有两个操作数，真值表如下：

第一个操作数|第二个操作数|结果
---|---|---
true|true|true
true|false|true
false|true|true
false|false|false
- 与逻辑与操作相似，逻辑或操作可以应用于任何类型的操作数，在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，此时遵循下列规则：
  - 如果第一个操作数是对象，则返回第一个操作数；
  - 如果第一个操作数的求值结果为false，则返回第二个操作数；
  - 如果两个操作数都是对象，则返回第一个操作数；
  - 如果有一个操作数是null，则返回null；
  - 如果有一个操作数是NaN，则返回NaN；
  - 如果有一个操作数是undefined，则返回undefined；
- 逻辑或操作也属于短路操作，即如果第一个操作数能够决定结果，就不会对第二个操作数求值。

##### 3.5.4 乘性操作符
- ECMAScript定义了3个乘性操作符：乘法、除法和求模。
- 在操作数为非数值的情况下会调用Number()转型函数将其转换为数值。

###### 1. 乘法
- 乘法操作符由一个星号(*)表示，用于计算两个数值的乘积。
- 在处理特殊值的情况下，乘法操作符遵循下列特殊的规则：
  - 如果操作数都是数值，执行常规的乘法计算。
  - 如果有一个操作数是NaN，则结果是NaN。
  - 如果是Infinity与0相乘，则结果是NaN。
  - 如果是Infinity与非0相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号。
  - 如果是Infinity与Infinity相乘，则结果是Infinity。
  - 如果有一个操作数不是数值，则再后台调用Number()将其转换为数值，然后再应用上述规则。

###### 2. 除法
- 除法操作符由一个斜线符号(/)表示，执行第二个操作数除第一个操作数的计算。
- 在处理特殊值的情况下，除法操作符遵循下列特殊的规则：
  - 如果操作数都是数值，执行常规的除法计算。
  - 如果有一个操作数是NaN，则结果是NaN。
  - 如果是Infinity被Infinity除，则结果是NaN。
  - 如果是零被零除，则结果是NaN。
  - 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。
  - 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。
  - 如果有一个操作数不是数值，则再后台调用Number()将其转换为数值，然后再应用上述规则。

###### 3. 求模
- 求模（余数）操作符由一个百分号(%)表示。
- 求模操作符会遵循下列特殊规则来处理特殊的值：
  - 如果操作数都是数值，执行常规的除法计算，返回除得的余数。
  - 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN。
  - 如果被除数是有限大的数值而除数是零，则结果是NaN。
  - 如果是Infinity被Infinity除，则结果是NaN。
  - 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数。
  - 如果被除数是零，则结果是零。
  - 如果有一个操作数不是数值，则在后台丢用Number()将其转换为数值，然后再应用上述操作。

##### 3.5.5 加性操作符
- 加性操作符有加法和减法两个。

###### 1. 加法
- 加法操作符(+)的规则如下：
  - 如果两个操作符都是数值，执行常规的加法计算。
  - 如果有一个操作数是NaN，则结果是NaN。
  - 如果是Infinity加Infinity，则结果是Infinity。
  - 如果是-Infinity加-Infinity，则解决过是-Infinity。
  - 如果是Infinity加-Infinity，则结果是NaN。
  - 如果是+0加+0，则结果是+0。
  - 如果是-0加-0，则结果是-0。
  - 如果是+0加-0，则结果是+0。
  - 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来。
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来。
  - 如果有一个操作数是对象，数值或布尔值，则调用它们的toString()方法取得对应的字符串值，再应用上述关于字符串的规则。
  - 对于undefined和null，则分别调用String()函数取得字符串"undefined"和"null"。

###### 2. 减法
- 减法操作符(-)的规则如下：
  - 如果两个操作符都是数值，则执行常规的算数减法操作并返回结果。
  - 如果有一个操作数是NaN，则结果是NaN。
  - 如果是Infinity减Infinity，则结果是NaN。
  - 如果是-Infinity减-Infinity，则结果是NaN。
  - 如果是Infinity减-Infinity，则结果是Infinity。
  - 如果是-Infinity减Infinity，则结果是-Infinity。
  - 如果是+0减+0，则结果是+0。
  - 如果是+0减-0，则结果是-0。
  - 如果是-0减-0，则结果是+0。
  - 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN。
  - 如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值，如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

##### 3.5.6 关系操作符
- 关系操作符有：小于(<)，大于(>)，小于等于(<=)，大于等于(>=)。
- 关系操作符返回的都是一个布尔值。
- 当关系操作符操作数使用了非数值时，会遵循以下规则：
  - 如果两个操作数都是数值，则执行数值比较。
  - 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
  - 如果一个操作数是数值，则将两一个操作数转换为一个数值，然后执行数值比较。
  - 如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并一ongoing得到的结果按照前面的规则进行比较。
  - 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。
  - 任何数与NaN进行关系比较，结果都是false。

##### 3.5.7 相等操作符
- 相等操作符用于确定两个变量是否相等。
- ECMAScript的相等操作符有两组操作符：  
相等和不相等——先转换再比较  
全等和不全等——仅比较而不转换

###### 1. 相等和不相等
- 相等操作符由两个等于号(==)表示，如果两个操作数相等，则返回true。
- 不相等操作符由叹号和等于号(!=)表示，如果两个操作数不相等，则返回true。
- 这两个操作符都会先转换操作数（通常称为强制转型）然后再进行比较。
- 在转换不同类型的数据时，相等和不相等操作符遵循下列规则：
  - 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1。
  - 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值。
  - 如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型按照上述规则进行比较。
  - null和undefined是相等的。
  - 要比较相等性之前，不能将null和undefined转换成其他任何值。
  - 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。
  - 即使两个操作数都是NaN，相等操作符也返回false。
  - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true，否则返回false。

###### 2. 全等和不全等
- 除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没什么区别。
- 全等操作符由3个等于号(===)表示，只有在两个操作数未经转换就相等的情况下返回true。
- 不全等操作符由一个叹号后跟两个等于号(!==)表示，在两个操作数未经转换就不相等的情况下返回true。
- null == undefined会返回true，但null === undefined会返回false。

##### 3.5.8 条件从操作符
- 遵循与Java中的条件操作符相同的语法形式。如下例子所示：

```
varibale = boolean_expression ? true_value : false_value;
```
- 如果对boolean\_expression求值结果为true，则给变量variable赋true\_value值，如果求值结果为false，则给变量variable赋false_value值。

##### 3.5.9 赋值操作符
- 简单的赋值操作符由等于号(=)表示，其作用就是把右侧的值赋给左侧的变量。
- 如果在等于号(=)前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。如：

```
var num = 10;
num = num + 10;
// 第二行可以用复合赋值来代替
num += 10;
```
- 每个主要算数操作符（以及个别的其他操作符）都有对应的复合赋值操作符。如下：
  - 乘赋值(*=)
  - 除赋值(/=)
  - 摸赋值(%=)
  - 加赋值(+=)
  - 减赋值(-=)
  - 左移赋值(<<=)
  - 有符号右移赋值(>>=)
  - 无符号右移赋值(>>>=)
- 这些操作符主要是简化赋值操作，并不会带来性能提升。

##### 3.5.10 逗号操作符
- 使用逗号操作符可以在一条语句中执行多个操作。
- 逗号操作符多用于声明多个变量。

```
var num1 = 1, num2 = 2, num3 = 3;
```

#### 3.6 语句
- ECMA-262规定了一组语句（也称为流程控制语句）。

##### 3.6.1 if语句
- if语句的语法：

```
if (condition) 
    statement1 
else 
    statement2
// statement1（语句1）statement2（语句2）可以是一行代码也可以是代码块
// 建议即使执行的只有一行代码，也使用代码块，即
if (condition) { 
    statement1 
} else { 
    statement2 
}
```
- 其中condition（条件）可以是任意表达式，而且对这个表达式求值的结果不一定是布尔值，ECMAScript会自动调用Boolean()转型函数对这个表达式的结果转换为一个布尔值。

##### 3.6.2 do-while语句
- do-while语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。

```
do {
    statement
} while (expression);
```
- 只要expression的求值结果为true，statement语句就会一直执行。
- do-while这种后测试循环语句最常用与循环体重的代码至少要被执行一次的情形。

##### 3.6.3 while语句
- while语句属于前测试循环语句，也就是说，在循环体内的代码被执行前，就会对出口条件求值。

```
while (expression) {
    statement
}
```
- 只有expression的求值结果为true，才会执行statement的语句。

##### 3.6.4 for语句
- for语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。

```
for (initialization; expression; post-loop-expression) {
    statement
}
```
- initialization为初始化变量，expression求值结果为true，就会执行statement的语句，循环后再执行post-loop-expression的表达式，然后再对expression求值。
- 在for循环的变量个初始化表达式中，也可以不适用var关键字，该变量的初始化可以在外部执行，例如：

```JavaScript
var i;
for (i = 0; i < 10; i++) {
    alert(i);
}
```
- 由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问。
- for语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这两个表达式全部省略，就会创建一个无限循环，例如：

```JavaScript
for (;;) { //无限循环
    doSomething();
}
// 只给出控制表达式实际上就把for循环转换成while循环
var i = 0;
for (; i < 10; ) {
    alert(i);
    i++;
}
```
- 由于for语句存在极大的灵活性，因此它也是ECMAScript中最常用的一个语句。

##### 3.6.5 for-in语句
- for-in语句是一种精确的迭代语句，可以用来枚举对象的属性。

```
for (property in expression) {
    statement
}
```
- ECMAScript对象的属性没有顺序，因此通过for-in循环输出的属性名的顺序是不可预测的。
- 如果要迭代的对象的变量值为null或undefined，for-in语句就会跑出错误。ECMAScript5更正了这一行为，对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值是不是null或undefined。

##### 3.6.6 label语句
- 使用label语句可以在代码中添加标签，以便将来使用：

```JavaScript
label: statement
// 示例：
start: for (var i = 0; i < 10; i++) {
    alert(i);
}
```
- 定义的label标签可以在将来由break或continue语句引用，加标签的语句一般都要与for语句等循环语句配合使用。

##### 3.6.7 break和continue语句
- break和continue语句用于在循环中精确地控制代码的执行。其中break语句会立即退出循环，强制继续执行循环后面的语句。而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。
- break和continue语句都可以与label语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下。
- 虽然连用break、continue和label语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。建议如果使用label语句，一定要使用描述性标签，同时不要嵌套过多的循环。

##### 3.6.8 with语句
- with语句的作用是将代码的作用域设置到一个特定的对象中。

```
with (expression) {
    statement
}
```
- 定义with语句的目的主要是为了简化多次编写同一个对象的工作，如下例子所示：

```JavaScript
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
// 以上代码都包含location对象，可以使用with语句
with (location) {
    var qs = search.substring(1);
    var hostName = hostname;
    var url = href;
}
```
- 在with语句的代码块内部，每个变量首先被认为是一个局部变量，如果在局部环境中找不到该变量的定义，就会查询with关联的对象中是否有同名属性。
- 大量使用with语句会导致性能下降，同事也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

##### 3.6.9 switch语句
- ECMAScript中switch语句的语法与其他基于C的语言非常接近。语法如下

```
switch (expression) {
    case value : statement
        break;
    case value : statement
        break;
    case value : statement
        break;
        default : statement
}
```
- switch语句中每一种情形(case)的含义是：如果表达式(expression)等于这个值(value)，则执行后面的语句(statement)。
- 关键字break会导致代码执行跳出switch语句。如果省略break，则会继续执行下一个case。
- default关键字则用于表达式不匹配前面任何一种情形的时候，执行机动代码。
- switch语句可以让开发人员免于编写大量if-else if的语句。
- ECMAScript中的switch语句虽然是借鉴自其他语言，但这个语句也有自己的特色。首先可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论字符串，还是对象都没有问题，其次，每个case的值不一定是常量，可以是变量，甚至是表达式。
- switch语句在比较值的时候使用的是全等操作符，因此不会发生类型转换。

#### 3.7 函数
- ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体。

```
function functionName(arg0, arg1, ... , argN) {
    statements
}
```
- 调用函数可以通过函数名后面加上一对圆括号和参数来调用。
- ECMAScript中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过return语句后跟要返回的值来实现返回值。
- 函数会在return语句后停止并立即退出，在return语句之后的任何代码都不会被执行。
- 一个函数可以有多个return语句，使用条件控制语句来实现不同情况下的退出。
- return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。
- 严格模式对函数有一些限制：
  - 不能把函数命名为eval或arguments；
  - 不能把参数命名为eval或arguments；
  - 不能出现两个参数同名的情况。
  - 如果发生以上情况，就会导致语法错误，代码无法执行。

##### 3.7.1 理解参数
- ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么类型数据。
- ECMAScript中的参数在内部是用一个数组来表示的，在函数体内可以用过arguments对象来访问参数数组。arguments对象只是与数组类似（并不是Array的实例）。
- 可以使用方括号语法访问arguments的每一个元素（即第一个元素是arguments[0]，第二个元素是arguments[1]，以此类推），使用length属性可以确定传进来多少个参数。
- 命名的参数值提供便利，但不是必须的。

##### 3.7.2 没有重载
- ECMAScript函数不能像传统意义上那样实现重载。如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。
